# 预取后台数据提高性能

> 原文 (Medium) ：[Improving performance with background data prefetching](https://instagram-engineering.com/improving-performance-with-background-data-prefetching-b191acb39898)
>
> 作者 ：Lola Priego

Instagram 社区比以往任何时候都更大更多样化。 现在，每个月有8亿人来访，其中80% 都在美国之外。 随着社区的发展，我们的应用程序能够承受多样化的网络条件、越来越多的设备和非传统的使用模式变得越来越重要。 纽约 Instagram 的客户业绩团队致力于让 Instagram 变得更快更正式，不管是在哪里使用它。 

具体来说，我们的团队优先考虑即时内容交付，在网络上零浪费字节，在磁盘上零浪费字节。 我们最近决定关注有效的后台预取，以此来打破 Instagram 可用性与网络可用性和用户数据计划的依赖的一种方式。	

### 条件

#### 网络可用性

![](https://ws2.sinaimg.cn/large/006tNc79gy1ftbviqx1foj30j409fmzz.jpg)

世界上大部分地区都没有足够的网络连接。 我们的数据科学家 Michael Midling 在世界各地的不同国家使用 Instagram 时，将这张地图放在一起，表示平均网络带宽。 像加拿大这样的深绿色区域，大约有4 + Mbps，相对于较轻的绿色区域，如印度，平均网络带宽为1 Mbps。

我们不能假设当用户打开 Instagram 并开始观看故事或者浏览 feed 时，媒体就可以观看了。 如果你想在印度建立一个快速媒体应用程序，那里的网络可用性并不丰富，而且往返时间可能超过2秒钟，那么你需要制定一个与实时获取资源不同的策略。 如果我们希望每个人都能访问 Instagram，看到他们最亲密的朋友和兴趣爱好的视频和照片，我们就必须能够对不同的网络带宽速度做出反应。 构建适应这些网络条件的应用程序具有挑战。

#### 数据敏感度

我们的一个解决方案是将用户的连接类型添加到日志事件中。 这使我们能够观察到不同的使用模式被连接类型划分，这有助于我们适应。 我们努力尊重人们的数据计划，并试图最大限度地利用无计量连接获得的数据。

![](http://ww4.sinaimg.cn/large/006tNc79gy1frl5a10iv5j30gq07lmx0.jpg)

这个图表显示了世界各地的 instagram 如何访问我们的应用程序。 例如，我们需要适应印度尼西亚的网络模式，印尼人主要在蜂窝连接上访问这个应用程序，一旦用完数据，用户即可从一张 SIM 卡切换到另一张 SIM 卡。另一方面，巴西人通常使用我们的应用程序通过 wifi。

#### 网络故障

![](https://ws1.sinaimg.cn/large/006tNc79gy1ftbvj2590qj30ak0ikgmt.jpg)

如果整个网络都失败了怎么办？ 从历史上看，我们会显示一个灰色盒子的屏幕，希望用户在有更好的连接时回来并重试。 但这不是一个好的体验。

![](https://ws4.sinaimg.cn/large/006tNc79gy1ftbvjbutrnj30an0iyjtj.jpg)

零星的网络连接和蜂窝网络拥塞也是关注的问题。 当我们处于上面地图的一个浅绿色区域，那里的网络带宽很低，我们需要找到一种方法来缩短或消除人们的等待时间。

我们的目标是让人们没有将网络连接视为在线，但没有一个适合所有人的解决方案。 以下是我们应用的一些技术，可将离线体验适应不同条件下的不同使用情况。

### 解决方案

我们想出了一系列的策略。 首先，我们专注于构建离线模式的体验。 有了这样的经验，我们解开了从磁盘传递内容的可能性，就好像它来自网络一样。其次，利用这种缓存基础架构，我们构建了一个集中式后台预取框架，用不可见的内容填充缓存。

#### 离线原则

通过数据分析和用户研究，我们提出了一些原则来代表主要的疼痛点和需要改进的地方:

1. 离线是一种状态，而不是一个错误
2. 离线体验是无缝的
3. 通过清晰的沟通建立信任

你可以在视频中看到这是如何实现的:

[Background Prefetching | youtube.com](https://youtu.be/fFH4MSrjcrY)

#### 解耦网络可用性和应用程序可用性

使用响应存储、图像和视频缓存，我们可以给用户界面提供内容，而不会从网络中获取内容，从而模拟成功的网络调用。

有三个主要组件: 设备屏幕，构成 HttpRequests 的设备网络层，以及负责将我们的网络请求传递给服务器的设备网络引擎。 

在建立了从磁盘上提供内容的能力之后，我们注意到人们在高增长市场上使用 Instagram 的方式有所改善。 我们决定在从网络下载之后缓存内容，相信看到旧内容比看到灰色的盒子和白色的屏幕要好。 但是理想的解决方案仍然是显示新的内容。 这就是后台预取的地方。

### 架构

在 Instagram，我们的工程价值观之一是"先做简单的事情"，所以我们的第一个方法不是构建完美的后台预取框架。 第一个原型只是在应用程序有后台时预取数据，前提是用户是在 wifi 连接下。 这个 BackgroundPrefetcher 迭代了一个 runnables 列表，一个一个执行。 

这第一个原型允许我们:

1. 对预取的内容进行迭代
2. 分析在用户体验中传递不可见的缓存内容的实际效果
3. 基准最终架构(稳定性)

```Java
public void registerJob(Runnable job) {
  mBackgroundJobs.add(job);
}
@Override
public void onAppBackgrounded() {
  if (NetworkUtil.isConnectedWifi(AppContext.getContext())) {
    while (!mBackgroundJobs.isEmpty()){   
    mSerialExecutor.execute(mBackgroundJobs.poll());
  }
 }
}
```

事实上，应用程序是复杂的，人们也是如此！ 当决定要预取什么类型的媒体时，你必须仔细分析使用模式。 例如，有些人可能比其他人更多地使用某些功能。

我们的主屏幕上有各种各样的项目，从故事托盘到个人的故事媒体。 我们还可以预览 feed 照片和视频，你有未处理的消息，你可以在 Explore 中浏览项目，或者你最近的通知。 在我们的例子中，我们开始的很简单，只是为了探索、故事和主要的内容提供了一些媒介。

 建立一个足够灵活以适应不同用例的集中框架有助于我们适当地保持效率和规模。

除了能够在我们的框架中安排工作，在没有对后台进行控制的情况下提取数据，我们还在顶部添加了额外的逻辑。 将后台预取的逻辑集中到一个点上，使得可以应用规则并验证某些条件得到满足，例如:

- 控制连接类型  - > 无计量
- 取消工作 - > 如果条件发生变化或应用程序被取消，我们希望能够取消我们正在进行的任何工作
- 将请求集中在一起，只在最佳时间，在会话期间预取一次请求
- 收集指标→完成所有工作需要多长时间？ 我们在调度和运行后台预取工作方面有多成功？

#### 工作流程

![](https://ws1.sinaimg.cn/large/006tNc79gy1ftbvjrnz6vj30xz0k9gnj.jpg)

让我们来看看我们在 Android 上的后台预取策略的工作流:

- 当主活动启动时(这意味着应用程序会被预先接受) ，我们会实例化 BackgroundWifiPrefetcherScheduler。 我们还可以运行哪种类型的工作
- 此实例将自己注册为一个 BackgroundDetectorListener。 就上下文而言，我们已经实现了一个结构，它会告诉我们每次应用程序被禁用的时候都会告诉我们，如果我们想在应用程序被杀之前做些什么(比如向服务器发送分析)
- 当 BackgroundWifiPrefetcherScheduler 获得通知时，它调用我们自制的 AndroidJobScheduler 来调度后台预取工作。 它将通过 JobInfo 传递。 这个 JobInfo 包含了关于启动什么服务的信息，以及需要满足哪些条件才能启动此项工作。

我们的主要条件是延迟和无计量连接。 根据 Android 操作系统，我们可能会考虑其他事情，比如是否启用了省电模式。 我们已经尝试了不同的延迟值，我们仍然在努力提供一个个性化的体验。 目前我们只在两次会话之间进行一次后台预取。 为了决定应用的后台是什么时候，我们会计算你的平均会话时间(你多久访问一次 Instagram?) 使用标准差删除异常值(不要考虑那些你可能无法访问这个应用的时间，因为如果你是一个频繁的用户，则可以进入睡眠状态)。 我们的目标是在你的平均时间之前进行预取。

- 经过这段时间后，我们会检查连接条件是否满足我们的要求(无计 / 无线)。 如果是这样的话，我们将推出 BackgroundPrefetcherJobService。 如果没有，这将等待连接条件得到满足。 (如果适用，设备未处于省电模式)
- 后台服务将创建一个序列执行程序，以串行方式运行每个后台作业。 然而，在获得 http 响应后，我们以异步方式预取媒体
- 在所有的工作完成后，我们通知操作系统，这样我们的流程就可以被消灭，我们可以优化内存 / 电池寿命。 在 Android 上关闭这个运行服务对于释放不再使用的内存资源非常重要

所有这些都是用户范围内的。 当有人注销或者用户切换时，我们需要能够处理。 如果用户注销，我们将取消预定的工作以避免不必要地唤醒服务。

#### 5. IgJobScheduler

具体来说，对于 Android，我们:

1. 寻找在后台安排工作的有效方法，这样我们就可以在会话中保持数据并指定网络要求。
2. 分析了多少用户在棒棒糖(2014年发布的 Android 操作系统下) ，因为 Android JobScheduler 接口的 api 只能从这个操作系统开始使用。 事实证明，这是一个我们不能忽略的问题。 我们需要一个兼容棒棒糖的版本
3. 通过研究找到一个开源 / 现有的解决方案来为旧版本的 Android 系统安排工作。 尽管找到了很棒的库，但是没有一个适合我们的用例，因为它们依赖于 Google Play 服务。 在 Instagram 上，我们相信在 APK 的大小保持方面是我们的第一个考虑
4. 最后，我们最终为 Android JobScheduler api 构建了一个自定义兼容解决方案

#### 测量

在 Instagram 上，我们是非常重视数据驱动的，并且严格地衡量我们构建的系统的影响。 这就是为什么当我们设计后台预取框架时，我们也在思考应该采取什么样的指标来获得正确的反馈。 

事实上，我们依靠一个集中的框架来计算，也有助于我们在更高的层次上收集指标。 我们认为，非常重要的是，要准确地评估权衡，并能够回答有多少预取的字节未被使用或全局 CPU 回归是怎样造成的。

![](https://ws4.sinaimg.cn/large/006tNc79gy1ftbvk9df5mj30jd0c83yr.jpg)

有一点对我们很有帮助，那就是我们在每个网络请求策略中标记 / 关联一个网络请求，以指出其行为和类型。 这个应用已经嵌入了这个应用程序，但是我们利用它来切割我们预取的指标。 我们对已发射的 http 请求附加了请求策略，并指定请求是否为预取请求。 我们在策略中指定的另一件事是 requestType。 一个请求可以是特定的图像，视频，API，分析等等。 这将有助于我们:

- 请求优先排序
- 通过全局 CPU 回归、数据使用和缓存效率来等维度更好地分析权衡

```Java
/**
 * The policy behavior describes whether the associated request is  
needed to render something
 * on the screen, or not (e.g. prefetch).
 */
public enum Behavior {
 Undefined(-1),
 OffScreen(0),
 OnScreen(1),
 ;
 int weight;
 Behavior(int weight) {
  this.weight = weight;
 }
}
```

在这里，我们可以看到安卓代码库中定义的 requestPolicy 对象的快照。 当请求属于用户等待的内容时，我们定义了"在屏幕上"的请求。 offScreen 请求中的概率为1% 的用户不与请求的数据进行交互。

#### 高效缓存记录器

我们想知道我们实际使用了多少预取的字节，所以我们研究了缓存中的项目是如何被使用的。 我们以一种符合以下规格的方式建立了整个缓存记录器:

- 要有伸缩性。 它应该能够通过它的 API 支持新增加的缓存实例
- 具有容错性和鲁棒性。 它应该容忍缓存失败(没有日志记录操作)或跨越时间戳的不一致
- 要可靠。 它应该在不同的会话中保留数据
- 在日志记录中使用最小的磁盘和延迟。 缓存读写经常发生，因此我们希望添加最小的开销。 缓存读写过程中的日志记录会导致更多的崩溃和更高的延迟

![](https://ws1.sinaimg.cn/large/006tNc79gy1ftbvkkcogyj30k90w9ab0.jpg)

我们还想知道在添加新的背景预取请求时，我们使用了多少数据。 我们在设备上安装了一个分层的基础网络引擎，正如我们提到的，我们对每个网络请求都附加了一个 requestPolicy 请求策略。 这使得我们可以非常容易地追踪应用程序中的数据使用情况，并观察我们消耗了多少数据下载图片、视频、 JSON 响应等等。 

我们还想分析数据使用是如何在数据使用与 wifi 和数据使用之间分布的。 这打开了用不同的预取模式进行实验的可能性。

#### 其他好处

除了打破对网络可用性的依赖和减少蜂窝数据的使用之外，后台预取还能带来什么好处？ 如果我们减少了纯粹的请求数量，我们就会减少整个网络流量。 通过将未来的请求捆绑在一起，我们可以节省开销和电池寿命。

#### 预防回归

在实施后台预取之前，我们已经考虑到了导致全局 CPU 回归的潜在风险。 

你怎么会导致回归呢？ 让我给你举个例子。 想象一下我们的端点，服务于 API 来获得你的 Instagram 主要 feed。 每次打开 Instagram 获得最新的 feed 第一页时，A 的设备就会调用主要的 feed API 。 这个 API 有几个繁重的计算操作，比如根据看到的状态对内容进行排序和分类。 如果我们每次在两次会话之间进行后台预取，那么我们将大大增加负载，对吗？

 为了尽量减少服务器端的回归，我们的第一个版本的后台预览系统，feed 团队的一位工程师 Fei Huang 为后台预取打开了一个不同的端点。 这只是获取不在视图状态下新的 feed 文章，并返回最新的 N = 20项目。

### 结论

这是我们建立系统时的工作流程。 我们的团队没有向其他工程师开放 API，直到我们能够确保框架的质量和对用户的好处。

随着越来越多的人加入 Instagram，这项工作变得越来越重要。 我们期待着让 Instagram 变得更有效率，更符合全世界所有人的需求。

Lola Priego 是 Instagram New York 的客户绩效团队的软件工程师。





