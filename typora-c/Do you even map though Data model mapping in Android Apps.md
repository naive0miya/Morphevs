# 你了解映射吗？ Android 应用中的数据模型映射

> 原文 (overflow.buffer.com)：[Do you even map though? Data model mapping in Android Apps](https://overflow.buffer.com/2017/12/21/even-map-though-data-model-mapping-android-apps/)
>
> 作者：[Joe Birth](https://overflow.buffer.com/author/joe/)

[TOC]

在 GitHub 上发布了我们的[模板项目](https://github.com/bufferapp/android-clean-architecture-mvi-boilerplate)之后，我注意到的一个主要讨论之一是围绕层之间的数据模型映射。 现在，这个对话不仅仅发生在我们的模板周围——我注意到，这是一个常常出现在谈论 Clean Architecture 或一般的安卓应用程序时出现的讨论。  说实话，有时候很难知道正确的做法是什么 - 主要是由于它们存在某种形式的权衡。 正因为如此，我想看看当涉及到团队和项目时，模型映射的一些优缺点。

## 什么是模型映射？

在应用程序中，通常会有一些形式的数据模型，从一个来源获取并通过应用程序的层次，最终到达其使用的目的地。 在某些情况下，开发人员将决定将这些实例映射到数据模型的不同表示形式，这样实例就不会与整个应用程序紧密耦合。 有时模型的数据将是完全相同的，但在很多情况下，层模型表示将包含特定于该层的数据(如用户界面模型中的选定状态)。 

现在，有一些不同的情况下，你可能映射你的数据模型。 例如，Clean Architecture 将它作为其设计的一部分，以便有一个清晰的关注点分离。 问题是，简洁架构提供了一种完整的解决方案来构建你的应用程序。 尽管其他的架构方法(甚至仅仅是设计) ，如 MVP，MVI 在清洁的架构中更多的是一个细节。 但是，如果你没有使用简洁架构和类似于这些模式之一的模式作为项目的结构，那么你还需要映射模型吗？ 如果我的所有模型都在同一个模块中，为什么我要费心映射我的模型？ 在这篇文章中，我想简单地看一下这些不同的情况，尝试并以某种方式协助在应用程序中做出这些决定。 

## 项目中的数据模型

首先要注意的是，应用程序中的模型映射实际上取决于项目的结构和你正在处理的项目类型——对于你在项目中可能考虑的任何架构决策来说都是一样的。 例如，想象一个非常简单的应用程序，它没有数据库，也没有网络请求——一个简单的应用程序，它只显示一些硬编码信息的列表。 现在，我知道这些应用程序可能不是你日常工作中常用的东西，但是看在例子的份上，这个应用可能会是这样的: 

![](https://ws1.sinaimg.cn/large/006tNc79gy1frouukhmwgj31kw0r8tb5.jpg)

嗯，这是一个漂亮的应用程序，不是吗！ 我们的应用程序中有一个由 UI 直接使用的单一数据模型。 因为这些数据是硬编码到应用程序中的，所以我们永远不会将细节放在那个 UI 不需要的模型中——仅仅因为它已经是我们 UI 的代表。 所以我们在这里有一个硬编码的用户界面模型(这可能不是正确的解决方案，但是我们现在就继续下去吧)。 除非我们想在应用程序中添加某种形式的数据层，否则在这里对数据模型进行映射是没有意义的。 

但是，让我们假设我们的应用程序中的内容有所改变——我们现在从 API 中获取这些数据模型，它们不再在我们的应用中硬编码了。 现在看起来有点像这样: 

![](https://ws2.sinaimg.cn/large/006tNc79gy1frouup9ls8j31kw0p4tcx.jpg)

好的 cool - 所以现在我们的应用程序与 API 通信，抓取一个模型并返回给我们用于我们的活动(我已经排除了这里的复杂性，让我们想象一下 API 类包含了处理数据通信的接口和存储库)。 这看起来很不错，对吧？ 尽管我忘了指出一些与我们的模型有关的事情: 

–  我们的 API 返回的字段命名是使用下划线而不是驼峰式，所以我们需要做一些事情：

```java
@SerializedName("duration_millis")
var durationMillis: Int
```

这意味着我们需要使用 import 来使用这个注解，很可能是我们的 UI 不在乎的。 我们的用户界面模型甚至不应该关心这个细节。

–  我们可以认为这并不是那么糟糕，如果我们的模型很小而且永远不会增长，那么它可能不是一个问题。 但是在这里，我们打破了责任的界限，为未来的潜在问题让路。 

为了进一步深化这一点，让我们想象一下我们的应用程序正在进行下面的更改: 

–  我们现在添加了一个新的活动，我们需要将模型传递给这个活动 - 所以我们必须使该类实现 parcelable，这意味着我们的模型现在包含了对 Android 框架的引用，这个模型与从 API 中获取数据的模型是一样的，同样，在一些人看来，这可能不是一个问题，但我们正在打破责任的界限 。

–  最后，在我们的应用程序中，我们现在可以对其中的一个项目进行长时间的按下按钮，所以我们不得不在我们的模型中添加一个新的字段来跟踪模型是否被选中， 所以现在我们用来表示从网络中检索到的数据的模型也包含了这个模型的特定视图表示的数据， 如果我们继续在这里添加一些视图特定的逻辑和更多的视图特定字段，我们的模型开始变得臃肿，进入一种不可维护的状态 。

现在你可以看到，我们所拥有的这个模型，本来是用来表示应用程序中的 API 数据的，而这个模型正在突然变得充满了它所不关心的属性。 我们对这个模型做出的任何更改都会影响应用程序中的所有用途—— API 响应不应该知道的用户界面属性，在某些情况下，可能会有 UI 不关心的数据。 

好吧，让我们假设现在我们不会改变任何事情 - 我们对我们的团队有不同的看法，所以我们将继续我们的现状。 但是等等，现在我们的需求已经改变了，我们将在我们的数据库中缓存我们的对象。 我们还增加了一个数据管理器类，只是为了把这些分开一点: 

![](https://ws4.sinaimg.cn/large/006tNc79gy1frouv0paxij31kw0q1afi.jpg)

所以现在我们已经做到了这一点，我们仍然只是使用一个模型。 我在这里可以想到一些问题，以便在上面已经提到的问题之上进行构建: 

–  很可能我们的模型会有一些只与缓存相关的数据。 例如，假设我们想存储最后选择的日期字段以跟踪前 N 个选定的模型是否适用于任何功能。我们的 UI 不关心这些细节，我们的 API 不关心这个细节，我们会在获取前 N 个模型时使用这个字段，所以缓存层只会关心这个。 这又是导致责任线断裂并增加膨胀模型的情况。

–  与远程模型注解类似，我们的模型可能会有一些与缓存相关的注解， 也许你正在使用 Room，你需要使用@entity 注解(可能还有其他的) ，这又一次增加了你的模型的结构，并导致了许多的责任 。

可能还有其他问题，但我希望现在你能明白我想表达的意思。 在我们的一个应用程序中，有一个 Profile 模型从一开始就存在，这个模型是巨大的。 它被缓存，它包含 API 中获取的，并且包含在 UI 中显示出来的 —— 这个模型包含了很多不同的注解，android 框架代码和 UI 逻辑。  改变这种模式让人感到困惑，因此很容易被打破。

现在，解决这类问题的一个方法是将你的模型映射到其他的表示。 这可以通过几种不同的方式完成——也许你有一个 API 表示和一个 UI 表示，再一次，它是任何符合你的项目。 在我看来，最好将应用程序的每个层的责任分离出来——这意味着我们将有一个用于 API 响应，一个用于缓存，一个用于用户界面。 

![](https://ws4.sinaimg.cn/large/006tNc79gy1frouv8tg4ej31kw0u0gw3.jpg)

在我看来，这也使我们能够明确地分离责任。 看看上面的图表: 

–  我们的 API 响应模型代表了从 API 返回的数据的纯粹形式， 它将始终不含 android 框架，不会臃肿 (希望如此) ，并且改变这个模型将永远不会打破我们应用程序中的任何预期行为（如果我们改变了所需要的内容，我们的应用程序也不会编译）。 

–  用于缓存的模型表示我们在应用程序中本地存储的数据 在大多数情况下，这将保持不含 android 框架，不包含任何与 UI 相关的逻辑代码，并且给我们空间来存储这些对象周围的数据，而这些数据可能并不是我们的用户界面所需要的。 

–  最后，我们有一个数据模型来表示我们 UI 的状态。 如果需要，这个模型可能包含对 Android 框架的引用 （parcelable？），可以包含特定于此模型的 UI 逻辑，并且永远不会破坏 UI 之外的任何图层。

这里的映射并不过分。 对于小型应用程序来说，它是可管理的，但是当我们有一个大的应用程序时，我们可能会被映射器类淹没，从而在不同的实例之间进行映射。 但是现在，我想快速看一下简洁架构(然而，这些对话仍然可以应用于所有的架构)。 

![](https://ws1.sinaimg.cn/large/006tNc79gy1frouvhxc5lj31kw0pvdl4.jpg)

不管我们的项目是否在这里模块化，我们在我们的项目中有3个明确的责任线。 这些模型中的每一个都是它自己的数据层表示——它与我们之前的模型非常相似，只是我们现在对应用程序的领域层有一个单独的模型表示——这些是我们的核心业务规则，因此代表了应用程序的纯业务对象。 但是，对于数据层，我们有一个模型表示-我们谈到的缓存模型和 API 模型表示又如何呢？ 嗯，让我们来解决这个问题: 

![](https://ws1.sinaimg.cn/large/006tNc79gy1frouvofbi1j31kw0q30yv.jpg)

好的，很酷，所以现在我们的数据层中有一个  Cache 和 API 模型，这两个模型都映射到了域层中的模型。 现在，在这种情况下，我们的数据层已经知道了 Cache 模型和 API 模型，这不是一个必要的问题，因为我们可以很容易地从数据模型中映射到域模型表示。 然而，我在一些项目中看到了这种情况: 

![](https://ws4.sinaimg.cn/large/006tNc79gy1frouvtrwkvj31kw0m97b9.jpg)

数据层现在有它自己的数据表示， Cache 和 API 模型只是简单地映射到这一点。 现在，我个人对此并不确定。 我觉得它增加了一些复杂性超过需要，因为我们现在有3个模型在我们的数据层-我们像在创建一个责任线的中间点，但我们的数据层仍然与这些不同的概念紧密结合。 如果我们真的想要这种明确的分离路线，我们就会继续这样做: 

![](https://ws1.sinaimg.cn/large/006tNc79gy1frouwdc8p8j31kw0taavd.jpg)

至少通过这种方法，我们现在有了我们的数据层所暗示的责任分离，但是还没有达到。 现在，通过这种方法，你可以从数据层中添加额外的抽象层，但是这样的话，你就有了一个数据层，它不知道数据从哪里来，并且是独立于实现的。 但是就像在很多情况下一样，这个额外的抽象层可以增加更多的复杂性——所以只有在需要它的时候才有意义(例如，更大的应用程序，这个数据层可能变得臃肿或在其他情况下你认为这个抽象是必要的)。 

但是，在这种情况下，如果我们的应用程序有5层左右的图层，我们最终会得到大量的映射器。 因此，尽管这种关注点分离确实增加了一些好处，但也很明显，它带来了一些负面影响。 让我们来快速看一下这些: 

## 特定层模型保持简洁的膨胀

正如我们已经在这篇文章中提到的，对应用程序的不同层次有独立的模型可以帮助模型清除不必要的膨胀。 例如，拥有一个只包含 UI 特定逻辑的模型表示意味着它将永远包含这个 -- 它将永远不会有 Cache 逻辑或 API 模型注解。 同样的情况也适用于 Cache 模型和 API 模型，每个模型对于在代码中工作的开发人员来说更容易理解，因为这些类将会更加集中，而不会被膨胀覆盖。 正如前面提到的，我们的应用程序中的 Profile 类是一个单一的模型表示(自应用开发以来)——这个对象极其臃肿，难以理解数据来自何处以及数据去往何处。 层特定的模型可以很容易地帮助你克服这一问题。 

## 不太可能打破模型逻辑

我相信我们都曾经经历过这样的情况: 我们在一个应用程序的某个地方改变了一些东西，并且它在其他地方破坏了某些东西。 对单个模型表示的依赖性较少，可以减少在更改过程中破坏内容的可能性(好吧，你的测试应该能够捕捉到) ，这意味着你可以对一个层进行更改，而不用担心那些影响应用程序其他部分的更改。 因此，这使得你的模型和应用程序更容易维护和延伸。 

## 图层变得更加独立

如果你把你的应用程序分层(不管你是否使用模块化) ，每个图层的模型会使你的图层更加独立于其他图层。 这意味着，如果你需要切换图层，那么你可以很容易地做到这一点，而不必担心打破一个必要的依赖性，同时也包括模块化，如果你已经尽力创建一个清晰的分离线，那么通过一个共享的模型实例来紧密耦合这些图层是没有意义的。 

## 减少整个团队发生冲突的机会

使用这些不同的模型实例(并在这一明确的分离线上)的另一个好处是，模块的独立性使得工作得到控制，这意味着相互冲突的工作机会更大。 例如，如果工程师可以轻松地在应用程序特性的不同层面上工作，而不会与他们的工作相冲突——或者甚至在完全不同的功能上工作，而不用担心应用程序中的某些共享模型实例会以某种方式冲突他们的工作。 

## 更容易鼓励更小的，更集中的任务

基于上述情况，任务中的大量拉请求使得在拉请求中有很多事情发生的时候很难进行代码审查。 因为应用程序的一个特定层将有它自己的特定模型，你可以为特性创建一个图层或重构，而不需要触摸其他层，因为你已经拥有所有你需要在当前层内工作的层。 这使得手头的任务变得更小，更有针对性。 

在 Android 团队中，我们试图对每个请求执行最多600行的更改，这使得审查过程更容易，代码质量可能更高，因为专注于检查拉请求变得容易得多。 

## 映射模型可能是乏味的

因此，这是映射模型的缺点之一——在应用程序的每一个层之间进行映射可能会感到乏味。 首先，用户界面、缓存和 API 模型之间的映射乍一看是合理的——但如果你的应用程序有20个不同的数据模型，如果所有这20个模型都有嵌套模型，那么在这些情况下你会怎么做？ 当你的应用程序中有更多的层时，情况会变得更加单调乏味。 例如，在清洁的架构中，你可以说在3到6层之间，你是否在这里映射每一个模型？ 如果你不这样做，你就有点打破了关注点分离的要点，这让你觉得你应该在这里映射模型来收获所有的好处。 

这会让你处于一个棘手的位置，所以你要么最终映射所有模型，要么最终在应用程序中部分映射模型。 无论哪种方式，你都将被要求做一个权衡。 通过组织良好的包装结构，可以使模型之间的映射更加易于管理——我尚未发现一种工具或过程，使这种流程更加简单。 

## 性能开销

我还没有能够对数据模型的映射进行任何性能分析(如果有人有的话，我希望看到任何信息) ，但已经讨论过模型映射对应用程序性能的影响。 我不能完全确定这是否是一个显著的影响，尤其是当你在两层之间绘制小模型的时候。 但是我认为，在应用程序的多层之间映射大型和复杂的对象时，这个问题可能会出现。 

## 有时候，你不需要模型实例

在某些情况下，你甚至不需要在图层之间绘制一个模型。 例如，假设你有一个 API 返回的模型，该 API 具有嵌套错误对象，其中包含要在用户界面中使用的错误消息。 与其通过3-5层来传递，不如使用应用程序正在使用的工具。 例如，如果你使用的是 RxJava，则使用错误消息在数据流中引发错误 -- 这种方式将通过对应类的订阅来接收错误。 你甚至可以在必要的地方使用 Completables ——这些解决方案对于实现可能会有所不同，但是这样的方法可以帮助你在不需要的时候避免在不同层之间映射模型。 

## 这完全取决于团队和项目结构

最后，一切都取决于什么对你的团队最有效，以及你选择如何安排你的项目(甚至是你如何处理它是如何构建的)。 我认为这通常适用于软件开发中的许多实践，如果它对你的团队来说是有意义的和有效的话，那么这是很重要的-但是一定要记住一个解决方案，这个解决方案对于未来的开发人员来说可能是很有效的。 

## 结束

我希望通过这篇文章，你能够看到图层之间的映射模型在很多情况下是如何有意义的，以及它能带来的好处。 但与此同时，也帮助你认为也许有时根据具体情况可能并不完全有必要这样做。 我很想听听你如何在应用程序中映射模型，以及你的方法背后的决策 。

